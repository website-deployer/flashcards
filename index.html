<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcards</title>
    <!-- Load Tailwind CSS -->
    <!-- Note: Using CDN for development - in production, install Tailwind CSS as PostCSS plugin -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
    <!-- Use Inter font family -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles for dark/light mode transition */
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s, color 0.3s;
        }

        /* 3D Flip Animation */
        .card-container {
            perspective: 1000px;
        }
        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        .card-container.flipped .card-inner {
            transform: rotateY(180deg);
        }
        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2rem;
            border-radius: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .card-back {
            transform: rotateY(180deg);
        }
        
        /* Responsive Text Scaling - Default/Mobile */
        .card-content-front {
            font-size: 2.25rem;
            font-weight: 600;
            transition: font-size 0.3s;
        }
        .card-content-back-def {
             font-size: 1.5rem;
             font-weight: 600;
             transition: font-size 0.3s;
        }
        .card-content-back-ex {
             font-size: 1.125rem;
             transition: font-size 0.3s;
        }

        @media (max-width: 640px) {
            .card-content-front {
                font-size: 1.75rem;
            }
            .card-content-back-def {
                font-size: 1.25rem;
            }
            .card-content-back-ex {
                font-size: 1rem;
            }
        }

        /* --- Fullscreen Styles --- */
        /* Center the card within the fullscreen container and apply background */
        #flashcard-container:fullscreen,
        #flashcard-container:-webkit-full-screen,
        #flashcard-container:-moz-full-screen,
        #flashcard-container:-ms-full-screen {
            background-color: var(--bg-color, #f3f4f6); /* Fallback */
            --bg-color: theme('backgroundColor.gray.100');
            
            /* Apply dark mode background if <html> has dark class */
            .dark & {
                --bg-color: theme('backgroundColor.gray.900');
            }
            
            /* Use the computed background color */
            background-color: var(--bg-color);
            position: fixed; /* Ensures it covers everything */
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 0;
            cursor: pointer; /* Keep cursor pointer for flipping */
            z-index: 9999;
        }

        /* Make the card take up a large portion of the viewport in fullscreen */
        #flashcard-container:fullscreen #card-inner,
        #flashcard-container:-webkit-full-screen #card-inner,
        #flashcard-container:-moz-full-screen #card-inner,
        #flashcard-container:-ms-full-screen #card-inner {
            width: 80vw; 
            height: 70vh; 
            max-width: 90%;
            max-height: 90%;
            border-radius: 2rem;
        }

        /* Adjust text size for optimal viewing in fullscreen */
        #flashcard-container:fullscreen .card-content-front,
        #flashcard-container:-webkit-full-screen .card-content-front,
        #flashcard-container:-moz-full-screen .card-content-front,
        #flashcard-container:-ms-full-screen .card-content-front {
            font-size: 4rem; 
        }

        #flashcard-container:fullscreen .card-content-back-def,
        #flashcard-container:-webkit-full-screen .card-content-back-def,
        #flashcard-container:-moz-full-screen .card-content-back-def,
        #flashcard-container:-ms-full-screen .card-content-back-def {
            font-size: 2.5rem; 
        }
        
        #flashcard-container:fullscreen .card-content-back-ex,
        #flashcard-container:-webkit-full-screen .card-content-back-ex,
        #flashcard-container:-moz-full-screen .card-content-back-ex,
        #flashcard-container:-ms-full-screen .card-content-back-ex {
            font-size: 1.5rem; 
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl mx-auto">
        
        <!-- Header -->
        <header class="text-center mb-6">
            <h1 id="deck-title" class="text-3xl md:text-4xl font-bold text-gray-800 dark:text-gray-100">Flashcard Deck</h1>
        </header>

        <main>
            <!-- Progress Bar -->
            <div class="w-full h-2 mb-6 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden shadow-inner">
                <div id="progress-bar" class="h-full bg-indigo-500 transition-all duration-300 ease-in-out" style="width: 0%;"></div>
            </div>

            <!-- Flashcard Container - Target for Fullscreen -->
            <div id="flashcard-container" class="card-container w-full h-80 cursor-pointer mb-6" onclick="flipCard()">
                <div id="card-inner" class="card-inner">
                    <!-- Front of Card (Question / Root) -->
                    <div id="card-front" class="card-front bg-white border border-gray-200 dark:bg-gray-800 dark:border-gray-700">
                        <p class="card-content-front text-indigo-600 dark:text-indigo-400"></p>
                    </div>
                    <!-- Back of Card (Answer / Definition + Example) -->
                    <div id="card-back" class="card-back bg-indigo-100 border border-indigo-200 dark:bg-indigo-900 dark:border-indigo-800">
                        <div class="text-gray-800 dark:text-gray-100 p-4">
                           <p id="back-definition" class="card-content-back-def text-gray-800 dark:text-gray-100 mb-2"></p>
                           <p id="back-example" class="card-content-back-ex text-gray-600 dark:text-gray-300 italic"></p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Controls -->
            <div class="flex flex-col sm:flex-row items-center justify-between p-4 bg-white dark:bg-gray-800 rounded-xl shadow-md border border-gray-200 dark:border-gray-700">
                <button id="prev-btn" onclick="prevCard()" class="px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 font-semibold rounded-lg shadow-sm hover:bg-gray-300 dark:hover:bg-gray-600 transition duration-150 ease-in-out disabled:opacity-50 w-full sm:w-auto mb-3 sm:mb-0">
                    &larr; Previous
                </button>
                <div class="flex gap-4 items-center">
                    <!-- NEW SHUFFLE BUTTON -->
                    <button id="shuffle-btn" onclick="shuffleDeckAndRender()" title="Shuffle Cards" class="p-2 bg-yellow-500 text-white rounded-lg shadow-sm hover:bg-yellow-600 transition duration-150 ease-in-out">
                        <!-- Shuffle Icon (Lucide-React style, but as SVG) -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="16 3 21 3 21 8"/>
                            <line x1="4" y1="20" x2="21" y2="3"/>
                            <polyline points="21 16 21 21 16 21"/>
                            <line x1="15" y1="15" x2="16" y2="16"/>
                            <line x1="14" y1="12" x2="15" y2="13"/>
                            <line x1="8" y1="8" x2="9" y2="9"/>
                        </svg>
                    </button>
                    <!-- Theme Toggle Button -->
                    <button id="theme-toggle" title="Toggle Dark/Light Mode" class="p-2 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg shadow-sm hover:bg-gray-300 dark:hover:bg-gray-600 transition duration-150 ease-in-out">
                        <!-- Sun Icon (Light Mode) -->
                        <svg id="sun-icon" class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" style="display:none;">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                        </svg>
                        <!-- Moon Icon (Dark Mode) -->
                        <svg id="moon-icon" class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" style="display:block;">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                        </svg>
                    </button>
                    <!-- Fullscreen Button -->
                    <button id="fullscreen-btn" onclick="toggleFullscreen()" title="Toggle Fullscreen" class="p-2 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-lg shadow-sm hover:bg-gray-300 dark:hover:bg-gray-600 transition duration-150 ease-in-out">
                        <!-- Fullscreen Icon -->
                        <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-3v4m0 0h-4m4 0l-5-5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"/>
                        </svg>
                    </button>
                    <div id="card-counter" class="text-lg text-gray-600 dark:text-gray-300 font-medium">Card 0 / 0</div>
                    <button id="flip-button" onclick="flipCard()" class="px-6 py-3 bg-indigo-500 text-white font-semibold rounded-lg shadow-lg hover:bg-indigo-600 focus:outline-none focus:ring-4 focus:ring-indigo-300 transition-all duration-150">
                        Flip Card
                    </button>
                    <button id="next-btn" onclick="nextCard()" class="px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-sm hover:bg-indigo-700 transition duration-150 ease-in-out disabled:opacity-50 w-full sm:w-auto mt-3 sm:mt-0">
                        Next &rarr;
                    </button>
                </div>
            </div>
            
            <hr class="w-full border-t border-gray-300 dark:border-gray-700 my-8">

            <!-- URL Generator Section -->
            <div class="w-full bg-white dark:bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-200 dark:border-gray-700 mt-6">
                <h2 class="text-2xl font-bold text-gray-800 dark:text-gray-100 mb-4">Flashcard Link Generator</h2>
                <p class="text-gray-600 dark:text-gray-300 mb-4 text-sm">
                    Enter the <b>Deck Title</b> and your flashcards below, one per line. Use a <b>Colon</b> (:) for the term/definition, and an optional <b>Pipe</b> (|) to add example text.<br>
                    <span class="font-bold text-indigo-500">Format: Term:Definition | Example Text</span><br>
                    <span class="text-purple-600 dark:text-purple-400 font-medium">✓ Latin accent support: Use ^ for macrons (ā, ē, ī, ō, ū) or _ for underscores!</span><br>
                    <span class="text-green-600 dark:text-green-400 font-medium">✓ Cross-device compatible with compressed URLs!</span><br>
                    <span class="text-blue-600 dark:text-blue-400 font-medium">✓ Works on any device - no storage dependencies!</span>
                </p>
                
                <input type="text" id="title-input" class="w-full p-3 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-gray-100 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-gray-700 placeholder-gray-400 mb-3" placeholder="Enter Deck Title (e.g., Biology Terms)">

                <textarea id="card-input" rows="5" class="w-full p-3 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-gray-100 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-gray-700 placeholder-gray-400 mb-4 resize-none" placeholder="Example:&#10;ferociter:fiercely | He fought ferociter in battle.&#10;conspicit:catches sight of | She conspicit the enemy.&#10;intent^e:intently | He listened intent^e to the lecture."></textarea>
                
                <button onclick="generateLink()" class="w-full py-3 bg-green-500 text-white font-bold rounded-lg shadow-md hover:bg-green-600 transition duration-150 ease-in-out">
                    Generate Shareable Link
                </button>

                <!-- Data Management Buttons -->
                <div class="mt-4 grid grid-cols-1 sm:grid-cols-2 gap-3">
                    <button onclick="exportDeck()" class="py-2 px-4 bg-blue-500 text-white font-semibold rounded-lg shadow-sm hover:bg-blue-600 transition duration-150 ease-in-out">
                        📥 Export Deck
                    </button>
                    <button onclick="importDeck()" class="py-2 px-4 bg-purple-500 text-white font-semibold rounded-lg shadow-sm hover:bg-purple-600 transition duration-150 ease-in-out">
                        📤 Import Deck
                    </button>
                </div>

                <div id="link-output-container" class="mt-4 hidden">
                    <p class="text-sm font-medium text-gray-600 dark:text-gray-300 mb-2">Share this link:</p>
                    <div class="flex items-center">
                        <input type="text" id="link-output" readonly class="flex-grow p-3 border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 dark:text-gray-100 rounded-l-lg text-sm truncate">
                        <button onclick="copyLink()" class="p-3 bg-gray-700 text-white rounded-r-lg hover:bg-gray-800 transition duration-150 ease-in-out flex-shrink-0">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M8 2a1 1 0 000 2h2a1 1 0 100-2H8z" />
                                <path d="M3 5a2 2 0 012-2c1.248 0 2.213.792 2.85 1.775L9 5h1l.15-.225C10.787 3.792 11.752 3 13 3a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V5zm10 2a1 1 0 100 2h-3a1 1 0 100 2h3a1 1 0 100 2h-3a1 1 0 100 2H5V7h8z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>
                    <p id="copy-message" class="text-xs text-green-600 mt-1 opacity-0 transition duration-300">Link copied!</p>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- DATA ---
        // Removed default data as requested.
        const defaultCards = [];

        // --- Core Application State ---
        let currentDeck = [];
        let currentCardIndex = 0;
        let isFlipped = false;
        
        // --- DOM Elements ---
        const flashcardContainer = document.getElementById('flashcard-container');
        const cardFrontText = document.querySelector('#card-front .card-content-front');
        const cardBackDefEl = document.getElementById('back-definition');
        const cardBackExEl = document.getElementById('back-example');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const cardCounterEl = document.getElementById('card-counter');
        const deckTitleEl = document.getElementById('deck-title');
        const progressBarEl = document.getElementById('progress-bar');
        const linkOutputContainer = document.getElementById('link-output-container');
        const linkOutputEl = document.getElementById('link-output');
        const copyMessageEl = document.getElementById('copy-message');

        // --- Utility Functions ---

        /**
         * Formats Latin text with proper diacritical marks and accent formatting
         * Converts common Latin diacritical representations to proper Unicode characters
         */
        function formatLatinAccents(text) {
            if (!text) return text;
            
            // Check if text already contains proper Unicode diacritical marks
            // If it does, return as-is to avoid double-processing
            const hasUnicodeAccents = /[āēīōūăĕĭŏŭĀĒĪŌŪĂĔĬŎŬ]/.test(text);
            if (hasUnicodeAccents) {
                return text;
            }
            
            // Latin macron mappings (long vowels)
            const macronMap = {
                'a': 'ā', 'A': 'Ā',
                'e': 'ē', 'E': 'Ē', 
                'i': 'ī', 'I': 'Ī',
                'o': 'ō', 'O': 'Ō',
                'u': 'ū', 'U': 'Ū'
            };
            
            // Latin breve mappings (short vowels) - less common but included for completeness
            const breveMap = {
                'a': 'ă', 'A': 'Ă',
                'e': 'ĕ', 'E': 'Ĕ',
                'i': 'ĭ', 'I': 'Ĭ',
                'o': 'ŏ', 'O': 'Ŏ',
                'u': 'ŭ', 'U': 'Ŭ'
            };
            
            // Process text to handle various accent mark representations
            let formattedText = text;
            
            // Handle common Latin accent representations
            // Pattern 1: vowel + macron symbol (ā, ē, etc.)
            formattedText = formattedText.replace(/([aeiouAEIOU])̄/g, (match, vowel) => macronMap[vowel] || match);
            
            // Pattern 2: vowel + underscore (a_, e_, etc.) - common in some systems
            formattedText = formattedText.replace(/([aeiouAEIOU])_/g, (match, vowel) => macronMap[vowel] || match);
            
            // Pattern 3: vowel + caret (â, ê, etc.) - convert to macrons for Latin
            formattedText = formattedText.replace(/([aeiouAEIOU])\^/g, (match, vowel) => macronMap[vowel] || match);
            
            // Pattern 4: vowel + grave accent (à, è, etc.) - convert to macrons for Latin
            formattedText = formattedText.replace(/([aeiouAEIOU])`/g, (match, vowel) => macronMap[vowel] || match);
            
            // Handle breve accents if present (less common in Latin)
            formattedText = formattedText.replace(/([aeiouAEIOU])̆/g, (match, vowel) => breveMap[vowel] || match);
            
            // Handle other common Latin diacritics
            // Acute accents on vowels (á, é, etc.) - sometimes used in Latin
            formattedText = formattedText.replace(/([aeiouAEIOU])´/g, (match, vowel) => macronMap[vowel] || match);
            
            return formattedText;
        }

        /**
         * Shuffles an array in place (Fisher-Yates algorithm).
         */
        function shuffle(array) {
             for (let i = array.length - 1; i > 0; i--) {
                 const j = Math.floor(Math.random() * (i + 1));
                 [array[i], array[j]] = [array[j], array[i]];
             }
         }
         
        /**
         * Shuffles the current deck, resets to the first card, and renders.
         */
        window.shuffleDeckAndRender = function() {
            if (currentDeck.length <= 1) return; // No need to shuffle 0 or 1 card
            
            // 1. Shuffle the array
            shuffle(currentDeck);
            
            // 2. Reset the index and flip state
            currentCardIndex = 0;
            
            // 3. Render the first card in the new order
            renderCard();
            
        }


        // --- Dark Mode Logic ---

        /**
         * Applies or removes the 'dark' class on the HTML element.
         * @param {boolean} enable - True to enable dark mode, false for light.
         */
        function applyTheme(enable) {
            const htmlEl = document.documentElement;
            const sunIcon = document.getElementById('sun-icon');
            const moonIcon = document.getElementById('moon-icon');

            if (enable) {
                htmlEl.classList.add('dark');
                localStorage.setItem('theme', 'dark');
                sunIcon.style.display = 'block';
                moonIcon.style.display = 'none';
            } else {
                htmlEl.classList.remove('dark');
                localStorage.setItem('theme', 'light');
                sunIcon.style.display = 'none';
                moonIcon.style.display = 'block';
            }
        }

        /**
         * Toggles between light and dark mode.
         */
        window.toggleTheme = function() {
            const isDarkMode = document.documentElement.classList.contains('dark');
            applyTheme(!isDarkMode);
        }
        
        // --- Fullscreen Logic (Includes promise rejection handling for permission errors) ---

        /**
         * Toggles fullscreen mode for the flashcard container.
         */
        window.toggleFullscreen = function() {
            const container = document.getElementById('flashcard-container');
            
            try {
                let promiseResult;
                if (!document.fullscreenElement) {
                    // Request fullscreen
                    if (container.requestFullscreen) {
                        promiseResult = container.requestFullscreen();
                    } else if (container.webkitRequestFullscreen) { /* Safari */
                        promiseResult = container.webkitRequestFullscreen();
                    } else if (container.msRequestFullscreen) { /* IE11 */
                        promiseResult = container.msRequestFullscreen();
                    }
                } else {
                    // Exit fullscreen
                    if (document.exitFullscreen) {
                        promiseResult = document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) { /* Safari */
                        promiseResult = document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) { /* IE11 */
                        promiseResult = document.msExitFullscreen();
                    }
                }

                // If a Promise was returned (modern API), explicitly catch the rejection.
                if (promiseResult && typeof promiseResult.catch === 'function') {
                    promiseResult.catch(e => {
                        console.warn("Fullscreen operation failed due to browser/permission policy:", e.message);
                    });
                }
            } catch (e) {
                // Catch synchronous errors 
                console.warn("Fullscreen failed (sync error): This is often due to security restrictions in the embedded environment (iframe). The error was:", e.message);
            }
        }


        // --- Deck Initialization and Data Compression ---

        /**
         * Compresses flashcard data using a simple and reliable algorithm
         * Uses compact JSON structure and Base64 encoding
         */
        function compressDeckData(title, cards) {
            try {
                // Validate input data
                if (!title || !cards || !Array.isArray(cards)) {
                    throw new Error('Invalid input data for compression');
                }
                
                // Create a compact data structure with short property names
                const deckData = {
                    t: title, // title
                    c: cards.map(card => {
                        // Ensure each card has the required properties
                        if (!card || typeof card.question === 'undefined' || typeof card.definition === 'undefined') {
                            throw new Error('Invalid card structure');
                        }
                        return [
                            card.question || '',    // question
                            card.definition || '',  // definition  
                            card.example || ''      // example
                        ];
                    })
                };
                
                // Convert to JSON string with proper Unicode handling
                const jsonString = JSON.stringify(deckData);
                
                // Check if the string is too large for URL
                if (jsonString.length > 50000) {
                    throw new Error('Deck data is too large for URL compression');
                }
                
                // Use encodeURIComponent first to handle Unicode properly, then Base64 encode
                const uriEncoded = encodeURIComponent(jsonString);
                const compressed = btoa(uriEncoded);
                
                return compressed;
            } catch (error) {
                console.error('Compression failed:', error);
                console.error('Error details:', error.message);
                return null;
            }
        }

        /**
         * Decompresses flashcard data from compressed format
         */
        function decompressDeckData(compressedData) {
            try {
                // Base64 decode first
                const uriEncoded = atob(compressedData);
                
                // Then decode URI component to handle Unicode properly
                const jsonString = decodeURIComponent(uriEncoded);
                
                // Parse JSON
                const deckData = JSON.parse(jsonString);
                
                // Convert back to full format
                const result = {
                    title: deckData.t,
                    cards: deckData.c.map(card => ({
                        question: card[0],
                        definition: card[1],
                        example: card[2]
                    }))
                };
                return result;
            } catch (error) {
                console.error('Decompression failed:', error);
                console.error('Compressed data:', compressedData);
                return null;
            }
        }


        /**
         * Parses URL parameters to get compressed data, deck key, or legacy card data
         * Handles compressed data system, localStorage system, and legacy URL-based system
         */
        function parseUrlDeck() {
            const urlParams = new URLSearchParams(window.location.search);
            const compressedData = urlParams.get('data');
            const deckKey = urlParams.get('deck');
            const cardString = urlParams.get('cards');
            const titleString = urlParams.get('title');

            // New compressed data system (cross-device compatible)
            if (compressedData) {
                const deckData = decompressDeckData(compressedData);
                if (deckData) {
                    return {
                        title: deckData.title,
                        cards: deckData.cards,
                        error: null
                    };
                } else {
                    return {
                        title: 'Decompression Error',
                        cards: [],
                        error: 'Failed to decompress the flashcard data. The link may be corrupted.'
                    };
                }
            }

            // Legacy localStorage-based system (for backward compatibility)
            if (deckKey) {
                try {
                    // Try to load from localStorage first
                    const storedData = localStorage.getItem(deckKey);
                    if (storedData) {
                        const deckData = JSON.parse(storedData);
                        return {
                            title: deckData.title,
                            cards: deckData.cards,
                            error: null
                        };
                    } else {
                        return {
                            title: 'Deck Not Found',
                            cards: [],
                            error: 'The requested deck could not be found. It may have been deleted or the link is invalid.'
                        };
                    }
                } catch (error) {
                    return {
                        title: 'Deck Load Error',
                        cards: [],
                        error: 'Failed to load the deck from storage.'
                    };
                }
            }

            // Legacy URL-based system (for backward compatibility)
            if (!cardString && !titleString) return null;

            const result = {
                title: 'Custom URL Flashcards',
                cards: [],
                error: null
            };
            
            // Handle Title
            if (titleString) {
                result.title = decodeURIComponent(titleString).trim() || "Custom URL Flashcards";
            }

            // Handle Cards
            if (cardString) {
                try {
                    const decodedString = decodeURIComponent(cardString);
                    
                    const parsedCards = decodedString.split(';').map(cardEntry => {
                        let [mainPart, examplePart = ""] = cardEntry.split('|').map(s => s.trim());
                        const parts = mainPart.split(':');
                        
                        if (parts.length >= 2) {
                            const question = parts[0].trim();
                            const definition = parts.slice(1).join(':').trim(); 
                            const example = examplePart || "(Example text not provided)";

                            if (question && definition) {
                                return { 
                                    question: formatLatinAccents(question), 
                                    definition: formatLatinAccents(definition), 
                                    example: formatLatinAccents(example) 
                                };
                            }
                        }
                        return null; 
                    }).filter(card => card !== null && card.question && card.definition);
                    
                    if (parsedCards.length > 0) {
                        result.cards = parsedCards;
                    } else {
                        result.error = "Malformed or empty 'Term:Definition' pairs in the URL.";
                    }

                } catch (error) {
                    result.error = "Error decoding 'cards' parameter due to bad encoding.";
                    console.error("URL decoding error:", error);
                }
            } else {
                result.error = "Missing 'cards' parameter in the URL.";
            }

            return result;
        }

        /**
         * Loads the deck from URL or falls back to default cards and handles errors.
         */
        function initializeDeck() {
            const urlResult = parseUrlDeck();

            if (urlResult && urlResult.cards.length > 0) {
                // Successful URL Load
                currentDeck = urlResult.cards;
                deckTitleEl.textContent = urlResult.title;
                document.title = urlResult.title; // Update browser tab title
            } else if (urlResult && urlResult.error) {
                // URL Error Case (empty, malformed, or missing cards)
                currentDeck = [{ question: "Error Loading Deck", definition: urlResult.error, example: "Use the Generator below to create a valid link." }];
                deckTitleEl.textContent = urlResult.title;
                document.title = urlResult.title; // Update browser tab title
            } else {
                // Default Deck Case (No valid URL parameters AND no default cards)
                const defaultTitle = "Create Your First Deck";
                // Display placeholder card instead of default data
                currentDeck = [{ question: "Welcome to your Flashcards!", definition: "Use the Generator below to create a shareable deck.", example: "Or load a deck using a URL parameter." }];
                deckTitleEl.textContent = defaultTitle;
                document.title = defaultTitle; 
            }

            // Always shuffle (even if the deck has 1 item) and reset index for a fresh start
            shuffle(currentDeck);
            currentCardIndex = 0;
            renderCard();
        }

        // --- Flashcard UI Logic ---

        /**
         * Renders the current card's content and updates navigation state and progress.
         */
        function renderCard() {
            if (currentDeck.length === 0) return;

            const card = currentDeck[currentCardIndex];
            
            // Update Content with accent formatting
            cardFrontText.innerHTML = formatLatinAccents(card.question);
            cardBackDefEl.innerHTML = formatLatinAccents(card.definition);
            // Set example text, showing a placeholder if empty
            cardBackExEl.innerHTML = formatLatinAccents(card.example || "(No example text provided)");

            // Update Status
            cardCounterEl.textContent = `Card ${currentCardIndex + 1} / ${currentDeck.length}`;
            
            // Update Progress Bar
            const progress = (currentCardIndex + 1) / currentDeck.length * 100;
            progressBarEl.style.width = `${progress.toFixed(2)}%`;

            // Update Navigation Button States
            prevBtn.disabled = currentCardIndex === 0;
            nextBtn.disabled = currentCardIndex === currentDeck.length - 1;
            
            // Reset Flip State
            if (isFlipped) {
                flashcardContainer.classList.remove('flipped');
                isFlipped = false;
            }
        }

        /**
         * Toggles the flip state of the card.
         */
        window.flipCard = function() {
            if (currentDeck.length === 0) return;
            isFlipped = !isFlipped;
            flashcardContainer.classList.toggle('flipped');
        }

        /**
         * Moves to the next card in the deck.
         */
        window.nextCard = function() {
            if (currentCardIndex < currentDeck.length - 1) {
                currentCardIndex++;
                renderCard();
            }
        }
        
        /**
         * Moves to the previous card in the deck.
         */
        window.prevCard = function() {
            if (currentCardIndex > 0) {
                currentCardIndex--;
                renderCard();
            }
        }

        // --- URL Generator Functions ---

        /**
         * Generates the shareable URL based on the text inputs.
         * Uses compressed data for cross-device compatibility with significantly reduced URL length.
         */
        window.generateLink = function() {
            const titleInput = document.getElementById('title-input').value.trim();
            const cardInput = document.getElementById('card-input').value.trim();

            const rawLines = cardInput.split('\n')
                                     .map(line => line.trim())
                                     .filter(line => line.includes(':')); // Filter out lines without ':'
            
            if (rawLines.length === 0) {
                linkOutputEl.value = "Error: Please enter valid Term:Definition pairs.";
                linkOutputContainer.classList.remove('hidden');
                return;
            }

            // Parse cards from input
            const processedCards = rawLines.map(line => {
                let [mainPart, examplePart = ""] = line.split('|').map(s => s.trim());
                const parts = mainPart.split(':');
                
                if (parts.length >= 2) {
                    const question = parts[0].trim();
                    const definition = parts.slice(1).join(':').trim();
                    const example = examplePart || "(Example text not provided)";

                    if (question && definition) {
                        return { 
                            question: formatLatinAccents(question), 
                            definition: formatLatinAccents(definition), 
                            example: formatLatinAccents(example) 
                        };
                    }
                }
                return null;
            }).filter(c => c !== null);

            if (processedCards.length === 0) {
                linkOutputEl.value = "Error: Please ensure your cards have a Term and Definition separated by a colon.";
                linkOutputContainer.classList.remove('hidden');
                return;
            }

            // Compress the deck data
            const compressedData = compressDeckData(titleInput || "My Custom Deck", processedCards);
            
            if (!compressedData) {
                linkOutputEl.value = "Error: Failed to compress deck data. This may be due to special characters or data size.";
                linkOutputContainer.classList.remove('hidden');
                return;
            }

            // Check URL length and provide feedback
            const newUrl = `${window.location.protocol}//${window.location.host}${window.location.pathname}?data=${compressedData}`;
            const urlLength = newUrl.length;

            // Construct the URL with compressed data
            linkOutputEl.value = newUrl;
            linkOutputContainer.classList.remove('hidden');

            // Show compression statistics
            const originalLength = encodeURIComponent(JSON.stringify({
                title: titleInput || "My Custom Deck",
                cards: processedCards
            })).length;
            
            const compressionRatio = Math.round((1 - urlLength / originalLength) * 100);
            
            // Update the copy message to show compression info
            const copyMessage = document.getElementById('copy-message');
            copyMessage.textContent = `Link generated! ${compressionRatio}% size reduction (${urlLength} chars vs ${originalLength} chars)`;
            copyMessage.classList.remove('opacity-0');
            setTimeout(() => copyMessage.classList.add('opacity-0'), 5000);

            // Reload the new deck into the app preview
            initializeDeck();
        }

        /**
         * Copies the generated link to the clipboard.
         */
        window.copyLink = function() {
            linkOutputEl.select();
            try {
                // document.execCommand('copy') is used as navigator.clipboard might be restricted in iframes
                const successful = document.execCommand('copy');
                if (successful) {
                    copyMessageEl.classList.remove('opacity-0');
                    setTimeout(() => copyMessageEl.classList.add('opacity-0'), 2000);
                }
            } catch (err) {
                console.error('Copy failed:', err);
                linkOutputEl.setSelectionRange(0, 99999); 
            }
        }

        /**
         * Exports the current deck data as JSON for backup purposes
         */
        window.exportDeck = function() {
            if (currentDeck.length === 0) {
                alert('No deck to export!');
                return;
            }

            const deckData = {
                title: deckTitleEl.textContent,
                cards: currentDeck,
                timestamp: Date.now(),
                version: '2.0'
            };

            const dataStr = JSON.stringify(deckData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `flashcards_${deckData.title.replace(/[^a-zA-Z0-9]/g, '_')}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        /**
         * Imports deck data from a JSON file
         */
        window.importDeck = function() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const deckData = JSON.parse(e.target.result);
                        
                        if (!deckData.title || !deckData.cards || !Array.isArray(deckData.cards)) {
                            alert('Invalid deck file format!');
                            return;
                        }
                        
                        currentDeck = deckData.cards;
                        deckTitleEl.textContent = deckData.title;
                        document.title = deckData.title;
                        
                        currentCardIndex = 0;
                        shuffle(currentDeck);
                        renderCard();
                        
                        alert(`Successfully imported "${deckData.title}" with ${deckData.cards.length} cards!`);
                    } catch (error) {
                        alert('Error reading deck file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        /**
         * Clears all stored flashcard decks from localStorage
         */
        window.clearAllStoredDecks = function() {
            if (confirm('This will delete all stored flashcard decks from your browser. This action cannot be undone. Continue?')) {
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('flashcard_deck_')) {
                        keysToRemove.push(key);
                    }
                }
                
                keysToRemove.forEach(key => localStorage.removeItem(key));
                alert(`Cleared ${keysToRemove.length} stored decks.`);
            }
        }


        // --- Initialization on Load ---
        document.addEventListener('DOMContentLoaded', () => {
            // 1. Initialize Theme
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const storedTheme = localStorage.getItem('theme');
            
            if (storedTheme === 'dark' || (!storedTheme && prefersDark)) {
                applyTheme(true);
            } else {
                applyTheme(false);
            }

            // 2. Initialize Deck
            initializeDeck();

            // 3. Attach event listener for theme toggle
            document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
            
            // 4. Keyboard shortcuts for quick studying
            document.addEventListener('keydown', (e) => {
                // Ensure keypresses only affect card if input fields aren't focused
                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                    return;
                }
                
                if (e.key === 'ArrowRight') nextCard();
                else if (e.key === 'ArrowLeft') prevCard();
                else if (e.key === 's' || e.key === 'S') shuffleDeckAndRender(); // Added keyboard shortcut for shuffle
                else if (e.key === ' ' || e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                    e.preventDefault(); // Prevent spacebar from scrolling
                    flipCard();
                }
            });
        });
    </script>
</body>
</html>
